\chapter{Prototipo sviluppato}
\label{chap:3}
Nel capitolo precedente sono state esaminate le differenze sostanziali tra un'approccio basato su Rust in combinazione con WebAssmebly e uno basato su Node.js.
In questo capitolo si presenterà il prototipo sviluppato con l'obiettivo di comprendere l'impatto di tali differenze in un'applicazione pratica.
\section{Descrizione dell'applicazione}
Il prototipo sviluppato è un applicazione dedicata all'elaborazione digitale di immagini, concepita per simulare un contesto realistico in cui le operazioni richiedono una considerevole quantità di elaborazioni da parte della CPU.
\\Dato il limitato tempo disponibile, non è stato possibile esplorare in dettaglio il vasto campo del \emph{digital image processing}. Pertanto, sono state impiegate librerie preesistenti in entrambi i linguaggi, evitando di immergersi eccessivamente nella programmazione di basso livello.
\\L'architettura dell'applicazione segue un modello client-server in entrambe le implementazioni.
Il cliente ha il compito di fornire i file da elaborare insieme alle relative specifiche sulle modifiche da apportare.
Il server eseguirà le modifiche richieste e restituirà al cliente il percorso della nuova immagine, pronta per il download.
\\Nel processo di selezione delle possibili modifiche da apportare, è stato essenziale individuare due librerie nei rispettivi linguaggi utilizzati.
Successivamente, per garantire uniformità nelle opzioni di modifica disponibili, sono state estratte le seguenti funzionalità comuni: 
\begin{itemize}
    \item ridimensionamento;
    \item rotazione di 90°;
    \item ribaltamento in orizzantale;
    \item conversione in bianco e nero;
    \item regolazione del contrasto;
    \item modifica della luminosità;
\end{itemize}
Tali operazioni sono state selezionate poiché rappresentano funzionalità frequentemente utilizzate anche da utenti comuni, oltre a caratterizzarsi per la loro eterogeneità. Alcune di queste coinvolgono esclusivamente la manipolazione dei pixel, come ad esempio la rotazione e il ribaltamento, mentre altre, come la conversione in scala di grigi o la modifica del contrasto/luminosità, comportano modifiche dirette ai pixel stessi.
\begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[width=.7\linewidth]{images/pre.jpeg}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[width=1\linewidth]{images/post.jpg}
    \end{minipage}
    \caption[Esempio immagine pre/post elaborazione]{Esempio di immagine a cui sono state apportate tutte le elaborazioni specificate.}
\end{figure}
\newpage
\section{Implementazione in Rust e Wasm/WASI}
Per quanto riguarda l'implementazione si è deciso di partire dal prototipo sviluppato in Rust poiché rappresentava l'aspetto più innovativo e richiedeva un considerevole impegno in termini di tempo.
\\Si è resa inoltre necessaria la ricerca di un framework che consentisse la creazione di un web server per la gestione delle richieste utente.
\\La scelta è ricaduta su actix-web, un web framework potente ed estremamente veloce per Rust.
\\Il client è costituito una semplice pagina HTML contenente un form per il caricamento delle immagini e due riquadri che mostrano l'immagine pre e post modifiche.
Tale pagina eseguirà una richiesta AJAX al server, inviando il file da elaborare e le relative specifiche sulle modifiche.
\\Terminata l'elaborazione il server restituirà il percorso della nuova immagine pronta per essere scaricata.
\begin{figure}
    \begin{center}
            \includegraphics[width=1\columnwidth]{images/client.png}
    \end{center}
    \caption{View nel browser del client}
    \label{fig:client}
\end{figure}
\subsection{Actix-Web}
Lo studio del funzionamento del framework Actix-Web ha costituito un punto focale durante la fase inziale dell'implementazione.
\\Tale framework si è dimostrato estremamente flessibile ed adatto per lo sviluppo del prototipo in questione.
Grazie all'impiego di \textbf{extractors}, di \textbf{handlers} e di altre funzionalità integrate, la gestione di richieste HTTP è risultata intuitiva e diretta.
\\Al fine di garantire un codice più ordinato e manutenibile è stata presa la decisione di strutturare l'applicazione in diversi file.
Tra questi, il file primario è \textbf{main.rs}, che svolge un ruolo centrale nell'architettura complessiva.
\subsubsection{Configurazione server}

\begin{lstlisting}[language=rust, label=lst:RustWasi, caption={Porzione del file main.rs}, showstringspaces=false]
#[actix_rt::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(move || {
        App::new()
            .route("/", web::get().to(server::handlers::index))
            .route("/upload", web::post().to(server::handlers::upload))
            .service(fs::Files::new("/script", "./src/static/"))
            .service(fs::Files::new("/img", "./img/"))
            .app_data(state.clone())
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
\end{lstlisting}
Nel frammento di codice fornito, viene presentata la creazione di un HttpServer e un'istanza di App tramite il framework Actix-Web.
In Actix-Web, ogni server è costruito attorno a un'istanza di App, che consente di configurare le "regole di routing" per risorse di vario tipo, registrare servizi HTTP e gestire stato di livello applicazione.
\textbf{è presente lo state!!!!! cosa fare???}
\\Nel caso specifico, vengono configurate due regole di routing:
\begin{itemize}
    \item La prima regola gestisce le richieste dirette alla \textbf{home} del sito: in questo caso verrà semplicemente restituita la pagina index.html presente nella directory "static".
    \item La seconda regola gestisce richieste all'endpoint \textbf{upload}, per le quali è necessario ricevere un'immagine e le relative modifiche da apportare all'interno del modulo WebAssembly. Successivamente, verrà restituito il percorso della nuova immagine elaborata.
\end{itemize}
Si sottolinea che entrambe le regole di routing mappano le richieste a funzioni presenti all'interno del file \textbf{handlers.rs} nel modulo server.
\\Successivamente sono stati registrati due servizi HTTP  per garantire l'accesso a risorse statiche: script Javascript e immagini elaborate dall'applicazione.
\\Infine, dopo aver configurato il metodo di dispatching delle richieste ed aver messo a disposizione le risorse necessarie ai client, si è passati alla scrittura del codice nel file \textbf{handlers.rs}. Tale file, come suggerito dal nome, contiene gli handler delle richieste HTTP, con la conseguente esecuzione di codice WebAssmebly per richieste di modifica di immagini.

\begin{lstlisting}[language=Rust,caption={Operazioni principali presenti nel file handlers.rs}, showstringspaces=false]
#[derive(MultipartForm)]
pub struct ImageUpload {
    image: TempFile,
    scala: Text<f32>,
    contrasto: Text<f32>,
    luminosita: Text<i32>,
    ruota: Text<bool>,
    specchia: Text<bool>,
    bw: Text<bool>
}
#[derive(Serialize, Deserialize)]
pub struct Editings{
    scala: f32,
    ...
}
pub async fn index() -> HttpResponse {
    HttpResponse::Ok().content_type("text/html")
        .body(include_str!("../static/index.html"))
}

pub async fn upload(form: MultipartForm<ImageUpload>) -> HttpResponse {
    let time = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH);
    let filepath = format!("img/uploaded/{:?}_{}", time, 
        form.0.file_name.as_str());
    match form.0.image.file.persist(filepath) {
        Ok(_) => {
            let editings = Editings{
                scala : form.0.scala.0,
                ...
            };
            edit(editings)
        },
        Err(e) => {
            HttpResponse::InternalServerError().finish()
        },
    }
}
\end{lstlisting}
Nel codice quì presentato, si possono facilmente notare i due endpoint del prototipo: la funzione \textbf{index()} per richieste alla pagina home e la funzione \textbf{upload()} per richieste di elaborazione di immagini.
\\Per quanto riguarda la prima tipologia si risponde ai client semplicemente fornendo il file HTML statico "index.html".
\\Al contrario la gestione delle richieste di upload è notevolmente più articolata e per questo motivo coinvolge una funzione di supporto denominata \textbf{edit()}. Sarà questa funzione che si occuperà dell'istanziazione del modulo WebAssmebly/WASI e della sua esecuzione.
\\Si sottolinea anche il parametro ricevuto dalla funzione "upload": un \textbf{MultipartForm<ImageUpload>}.
Il framework Actix-Web, con il supporto del crate actix-multipart semplifica notevolmente la gestione di richieste provenienti da form html, anche in presenza di campi di input di tipo "file".
\\Ogni campo definito nella struttura "ImageUpload" corrisponde a un parametro proveniente dalla richiesta HTML e viene automaticamente popolato prima dell'invocazione dell'handler, consentendo un accesso immediato ai valori inviati al server.
\\In sintesi la funzione \textbf{upload()} rende persistente il file temporaneo ricevuto ed inoltre crea un ulteriore \emph{struct} di supporto (\textbf{Editings}) che verrà sfruttata dalla funzione \textbf{edit()} per velocizzare il successivo accesso alle elaborazioni da effettuare.
\\Va sottolineato che "edit()" viene invocata solo se il file è stato reso persistente senza errori. Infatti, tale funzione si occupa dell'istanziazione del modulo WebAssembly e non ha senso tentare di eseguire modifiche su un file che non è stato salvato correttamente.
\subsection{Integrazione modulo Wasm/WASI}
Come precedentemente indicato, per l'esecuzione di codice WebAssmebly, si è deciso di utilizzare il runtime environment \textbf{Wasmtime}.
La sua integrazione all'interno di un'applicazione Rust è resa possibile primariamente grazie ai crate \textbf{wasmtime}, \textbf{wasmtime-wasi} e \textbf{wasi-common}.
\subsubsection{Scambio di dati}
Prima ancora di iniziare l'implementazione è stato fondamentale trovare un modo per \textbf{scambiare dati} tra il modulo WebAssmebly e l'host.
\\Per soddisfare i requesti imposti in questa tesi, è necessario che il modulo WebAssmebly riceva tutte le elaborazioni da effettuare su un'immagine e il nome del file da modificare, ma come introdotto in sezione \ref{subsub:Valori}, una funzione WebAssmebly può ricevere solamente valori di \textbf{tipo numerico}.
\\Analizzando le API WebAssmebly e WASI sono emerse diverse soluzioni a questo problema. Tra queste l'utilizzo della memoria lineare, la scrittura su file, la modifica di variabili d'ambiente o la comunicazione attraverso standard input.
Tuttavia, alcuni di questi approcci potrebbero risultare complessi da implementare e considerando che per l'applicazione sviluppata sarebbe stato sufficiente scambiare una stringa per ottenere tutte le informazioni necessarie, si è scelto di adottare la comunicazione tramite \textbf{standard input}.
\\Nello specifico, per consentire lo scambio di dati tra host e guest, verrà implementato un protocollo composto dalla seguente sequenza di operazioni:
\begin{itemize}
    \item Serializzazione in formato JSON della struct "Editing" contenente tutte le elaborazioni  e il nome del file da modificare;
    \item Inserimento sullo standard input del modulo Wasm, della stringa ottenuta dalla serializzazione;
    \item Lettura della stringa da standard input all'interno del modulo, sfruttando le API messe a disposizione da WebAssmebly System Interface;
    \item Deserializzazione in una Struct Editing equivalente a quella di partenza;
\end{itemize}
Si noti che, se necessario, questo protocollo potrebbe essere applicato anche per ottenere strutture dati in output dal modulo WebAssembly.
\subsubsection{Condizioni necessarie per l'esecuzione}
Prima di poter eseguire un modulo tramite Wasmtime, sono necessarie diverse operazioni preliminari.
\\Dopo aver serializzato la struttura dati e predisposto una \textbf{ReadPipe} (crate wasi-common) per mettere a disposizione la stringa serializzata su standard input, la prima operazione necessaria è la creazione dell'\textbf{Engine} Wasmtime.
\\Esso rappresenta un contesto globale per la compilazione e l'esecuzione di moduli Wasm, che nel nostro specifico caso adotterà la configurazione di default.
\\Si procederà poi con l'istanziazione di un \textbf{wasmtime::Linker}. Il linker faciliterà l'istanziazione del modulo Wasm, risolvendo le diverse import (tra cui quelle per le syscall WASI).
\\Non bisogna poi dimenticare, che a causa dell'architettura di WASI, sarà possibile accedere ed utilizzare i file presenti in una certa directory, solamente se al programma sono state fornite le \textbf{capabilities} necessarie. 
\\Per ottenere le capabilities per operare sulle immagini caricate dagli utenti, è necessario aprire la cartella "img" prima dell'istanziazione del modulo WASI.

\begin{lstlisting}[language=rust, caption={File handlers.rs: operazioni preliminari}, showstringspaces=false]
pub fn edit(editing : Editings) -> HttpResponse {
    let serialized_input = serde_json::to_string(&editing);
    let stdin = ReadPipe::from(serialized_input);
    
    let engine = Engine::default();
    
    let mut linker: Linker<WasiCtx> = Linker::new(&engine);
    wasmtime_wasi::add_to_linker(&mut linker, |s| s); 
    let  image_directory = Dir::open_ambient_dir("img", ambient_authority());
    ...
}
\end{lstlisting}
A questo punto è possibile creare e configurare un contesto WASI tramite la struct \textbf{wasmtime\_wasi::WasiCtxBuilder}.
\\Tramite tale oggetto si specifica che lo standard input sarà prelevato dall'oggetto contenente la serializzazione, lo standard output e lo standard error saranno ereditati dalla macchina host ed infine si fornisce una directory precedentemente aperta, che sarà disponibile al percorso "img".
\\Sfruttando il contesto WASI è ora possibile la creazione dello \textbf{Store} Wasmtime, l'oggetto designato per l'effettiva istanziazione del modulo WebAssembly e che successivamente conterrà tutte le funzioni, la memoria, le tabelle e lo stato interno del programma.
\begin{lstlisting}[language=rust,caption={File handlers.rs: creazione di contesto WASI e Store}, showstringspaces=false]
    let builder = WasiCtxBuilder::new()
    .stdin(Box::new(stdin.clone()))
    .inherit_stdout()
    .inherit_stderr()
    .preopened_dir(image_directory,"img");
    let wasi = builder.build();
    
    let mut store = Store::new(&engine, wasi);
\end{lstlisting}
Ora risulta possibile la creazione del \textbf{Module} WebAssmebly e il suo collegamento con il Linker per poi ottenere, tramite quest'ultimo, un'\textbf{istanza} relativa al Module e allo Store specificati nel metodo \emph{linker.instantiate()}.
\begin{lstlisting}[language=rust,caption={File handlers.rs: istanziazione modulo Wasm}, showstringspaces=false]
    let module = Module::from_file(&engine, "src/server/image_proc_module.wasm");
    linker.module(&mut store, "", &module) 
    let instance = linker.instantiate(&mut store, &module);
\end{lstlisting}
\subsubsection{Esecuzione del modulo WebAssmebly}
Avendo configurato Store e contesto WASI, il programma possiede già tutti gli argomenti necessari per il corretto funzionamento e l'unico passo rimanente consiste nell'effettiva esecuzione della funzione del modulo WebAssmebly.
\\Per fare ciò è  necessario ottenere un'istanza di \textbf{wasmtime::Func} tramite l'operazione \emph{get\_typed\_func()} sull'istanza WebAssmebly.
A questo punto l'invocazione della funzione richiesta è finalmente possibile grazie al metodo \emph{Func::call()}.
\\Ad esecuzione terminata verrà eliminato lo store dalla memoria e restituito il percorso dell'immagine modificata al cliente.
\begin{lstlisting}[language=rust,caption={File handlers.rs: invocazione funzione \_start presente nel modulo Wasm}, showstringspaces=false]
    let instance_main = instance.get_typed_func::<(), ()>(&mut store, "_start");
    instance_main.call(&mut store, ());
    drop(store);
    HttpResponse::Ok()
    .content_type("text/plain")
    .body(e.modified_file_path)
\end{lstlisting}
Si noti che in questi esempi di codice non è presente alcuna gestione degli errori. Tuttavia nel prototipo sviluppato, l'utente finale otterrà il nuovo percorso del file, solo nel caso in cui ciascuna delle operazioni illustrate sarà andata a buon fine.
\subsection{Modulo WebAssmebly/WASI}
Il modulo WebAssmebly risulta a questo punto piuttosto semplice.
\\Esso si occupa infatti della lettura dei parametri da \textbf{standard input} e della loro deserializzazione in una struct Editings.
\\Successivamente vengono utilizzati i metodi forniti dal crate \textbf{image} di Rust per aprire l'immagine ricevuta, modificarla secondo le specifiche dell'utente e salvarla nel percorso specificato.\cite{rust:image}

\begin{lstlisting}[language=rust, caption={Codice Rust che successivamente verrà compilato in WebAssembly}, showstringspaces=false]
#[derive(Serialize, Deserialize)]
pub struct Editings{
    scala: f32,
    ...
}
fn main() {
    let mut serialized_params = String::new();
    std::io::stdin().read_to_string(&mut serialized_params);
    let editings : Editings = serde_json::from_str(&serialized_params);
    let mut img = image::open(editings.filepath)
    if editings.scala != 0.0 {
        let new_width = (img.width() as f32) * editings.scala;
        let new_heigth = (img.height() as f32) * editings.scala;
        img = img.resize(new_width as u32, new_heigth as u32, image::imageops::FilterType::Nearest);
    }
    if editings.ruota {
        img = img.rotate90();
    }
    ...
    img.save(editings.modified_filepath);
}
\end{lstlisting}
Terminata l'esecuzione del modulo, il controllo ritornerà all'host che si occuperà dell'invio di una risposta adeguata al client:
\begin{itemize}
    \item Se durante l'esecuzione del modulo Wasm tutte le operazioni sono terminate correttamente verrà restituito il percorso della nuova immagine generata;
    \item Altrimenti verrà restituito un messaggio di errore;
\end{itemize}
Terminata la scrittura del codice, è necessaria la compilazione per ottenere un modulo WebAssmebly utilizzabile da wasmtime.
\\Ciò si può fare agovelmente grazie al package manager \textbf{cargo}, ed in particolare grazie al seguente comando:
\begin{lstlisting}[language=Bash, numbers=none]
cargo build --release --target wasm32-wasi
        Compiling image_proc_module v0.1.0 (.\image_proc_module)
            Finished release [optimized] target(s) in 1.21s
\end{lstlisting}
In questo caso risulta pressochè obbligatoria la presenza del flag \textbf{- - release}, in quanto diverse funzioni del crate image, sono estremamente lente se utilizzate in debug mode.
\\Infine si sottolinea che avendo svolto tutte le operazioni necessarie nel main, nel momento in cui l'host invocherà il metodo \emph{get\_typed\_func()}, sarà necessario specificare la funzione denominata \textbf{\_start}.



\newpage
\section{Implementazione in Node.js}
Dopo aver terminato l'implementazione del prototipo mediante l'utilizzo di Rust e WebAssmebly, si è proceduto con l'implementazione di un applicazione dotata delle medesime funzionalità, questa volta utilizzando il runtime environment \textbf{Node.js}.
\\La seconda implementazione è risultata notevolmente più immediata.
In particolare è stato possibile riutilizzare il client sviluppato precedentemente, senza necessità di un'analisi approfondita per l'integrazione di un modulo WebAssmebly.
Come verrà sottolineato in seguito, ciò ha permesso di ottenere un \textbf{codice} decisamente più \textbf{pulito} e di lunghezza proporzionata alla semplicità dell'applicazione sviluppata.
\\La ricerca si è dunque focalizzata sulla selezione di un moduli adeguati per la creazione di un'applicazione web in grado di supportare l'upload e l'elaborazione di immagini.
La scelta è ricaduta sul web framework \textbf{express.js}, in combinazione con il middleware \textbf{multer} e la libreria \textbf{Jimp}.
\subsection{Express.js}
Express.js è un \textbf{web framework} che semplifica lo sviluppo di applicazioni web robuste e scalabili. Esso è stato riconosciuto come lo \textbf{standard de facto} in quest'ambito.
\\Il design di Express è relativamente minimale, tuttavia, grazie all'impiego di \textbf{plugin} e \textbf{middleware} come Multer, è in grado di fornire una vasta gamma di funzionalità.
\\Il framework inoltre rende più semplice il routing, gestendo richieste e risposte HTTP in modo semplice e diretto.
\\Per quanto concerne la nostra applicazione, dopo aver importato i moduli richiesti, è essenziale effettuare una configurazione breve ma precisa, per la gestione delle richieste necessarie e per la configurazione dell'upload dei file.
\begin{lstlisting}[language=JavaScript, caption={Configurazione Express.js}, showstringspaces=false]
    const express = require('express');
    const app = express()
    const port = 3000
        
    app.use(express.static('./static'))
    app.use(express.static('./img/modified'))
    
    app.post('/upload', upload.single('image'), (req, res) => {
      try{
      ...
      }
      } catch (error){
        console.log(error);
        res.status(500).send('Error processing the file');
      }
    })
    
    app.listen(port, () => {
      console.log(`Server listening on port ${port}`)
    })
\end{lstlisting}
Nello specifico viene creata un'applicazione Express tramite l'omonimo metodo \emph{express()}.
\\Successivamente tramite i metodi \emph{express.use(express.static(...))} vengono rese accessibili ai client le directory "static"(contenente il file HTML della home e gli script correlati) e "img/modified" (necessaria per il download delle immagini elaborate dal server).
\\Il server viene poi messo in ascolto sulla porta 3000 e configurato per gestire richieste di tipo POST dirette all'endpoint "/upload".
\\A questo punto, per la corretta gestione del caricamento di immagini, risulta necessario configurare l'applicazione affinché sia in grado di ricevere richieste con Content-Type "multipart/form-data".
\subsection{Multer}
Come introdotto inizialmente, per la gestione di richieste provenienti da un form contenente campi di input di tipo file, è stato adottato il middleware \textbf{multer}.
\begin{lstlisting}[language=Javascript, caption={Configurazione upload immagine}, showstringspaces=false]
const multer  = require('multer');
const storage = multer.diskStorage({
    destination: 'img/uploaded/',
    filename: (req, file, cb) => {
    cb(null, file.originalname);
    }
});
const upload = multer({ storage });
app.post('/upload', upload.single('image'), (req, res) => {
    ...
})
\end{lstlisting}
Una volta importato questo modulo, è necessario impostare, tramite il metodo \emph{multer.diskStorage()}, la destinazione (per coerenza viene mantenuta la directory img/uploaded) e il nome del file appena caricato (viene utilizzato lo stesso nome del file fornito dall'utente).
\\In seguito attraveso l'utilizzo del metodo \emph{multer()} otteniamo un'istanza, tramite la quale è possibile specificare, nei parametri della callback function per richieste all'endpoint upload, che un singolo file dovrà essere reso persistente, come precedentemente specificato nella variabile storage.
\subsection{Jimp}
Una volta terminata la configurazione del server tramite express.js, è possibile procedere con la modifica del file ricevuto. 
\begin{lstlisting}[language=Javascript,caption={Elaborazione immagine grazie ai metodi della libreria Jimp}, showstringspaces=false]
app.post('/upload', upload.single('image'), (req, res) => {
  try{
    const uploadededFilePath =                               'img/uploaded/' + req.file.originalname
    const newFileName =  Date.now() + req.file.originalname 
    const modifiedFilePath = 'img/modified/' + newFileName;

    Jimp.read(uploadededFilePath, (err, img) => {
      if (err) throw err
      else{
        img.scale(req.body.scala)
           .rotate(req.body.ruota)
           .mirror(req.body.specchia,false)
           .contrast(req.body.contrasto/100)
           .brightness(req.body.luminosita/100, function(){
              if(req.body.bw) img.grayscale()
              img.write(modifiedFilePath, function(){
                res.status(200).send(newFileName);
              });
          });
      }
    });

  } catch (error){
    res.status(500).send('Error processing the file');
  }
}
\end{lstlisting}
Il file è aperto mediante l'impego del metodo \textbf{Jimp.read()}, il quale fornisce un'istanza utilizzabile per moodificare l'immagine secondo specifiche.
Quest'ultime si possono essere acquisite  tramite l'oggetto req.body, passato alla callback function \emph{app.post('/upload',...)}.
\\Dopo aver apportato le opportune modifiche all'immagine, essa viene salvata nella cartella "img/modified" con un nuovo nome al fine di garantire univocità tra i vari file.
\\Infine, se tutte le operazioni precedenti vengono eseguite correttamente, verrà restituito all'utente il percorso dell'immagine modificata. In caso contrario, verrà restituito un messaggio di errore.
\newpage
\section{Metodologia di test}
Per verificare le prestazioni di ciascuna implementazione presentata, si è deciso di eseguire lo stesso set di test per entrambe.
In particolare è stata scelta una sola elaborazione e durante la sua esecuzione sono stati misurati diversi parametri.
Per scegliere la tipologia di operazione si è empiricamente tentato di carpire quale fosse, tra le elaborazioni implementate, quella più computazionalmente complessa.
Eseguendo vari test su una stessa immagine e verificando la latenza è stato scelto il \textbf{resize} di un'immagine.
In seguito sono state scelte le immagini di test e i parametri da misurare.
Per le immagini si è optato per tre file di dimensioni crescenti:
\begin{itemize}
    \item 1114 x 742 (0.82 Megapixel, 925 KiloByte);
    \item 2869 x 1912 (5.48 Megapixel, 4.63 MegaByte);
    \item 5578 x 3712 (20.7 Megapixel, 17.4 MegaByte);
\end{itemize}
Come parametri da misurare si ha optato per:
\begin{itemize}
    \item Latenza per ogni richiesta;
    \item Utilizzo di CPU;
    \item Consumo di memoria;
\end{itemize}
\section{Setup sperimentale}
Per eseguire i test presentati è stato utilizzato un laptop con processore Intel Core i5-10210 (1.6-2.10 GHz), 8 GigaByte di Ram e sistema operativo Windows 11.
Per quanto riguarda i software utilizzati, si sono scelte le ultime versioni al momento disponibili:
\begin{itemize}
    \item Rust 1.71
    \item Wasmtime 11.0
    \item Node 18.17.1 (LTS)
\end{itemize}
Il seguente setup, pur non essendo propriamente tipico di un server ha comunque permesso di osservare differenze evidenti tra i due apprrocci esaminati.
\newpage
\section{Valutazione delle prestazioni}
Per ottenere risultati affidabili e confrontabili sono state eseguite 10 misurazioni per ogni immagine.
In seguito sono stato calcolati il valore medio del campione ottenuto come media aritmetica e la deviazione standard:
\begin{equation*}
    E[X]=\frac{1}{n}\sum_{i=0}^{n}x_i
\end{equation*}
\begin{equation*}
    \sigma_X = \sqrt{\frac{1}{n}\sum_{i=0}^{n}(x_i-E[x])^2}
\end{equation*}
In ciascuno dei grafici che seguiranno saranno riportate le misurazioni per ognuna delle tre immagini utilizzate.
\subsection{Latenza}
\begin{figure}
    \begin{center}
            \includegraphics[width=1\columnwidth]{images/rust_latenza.png}
    \end{center}
    \caption{Latenza misurata utilizzando Rust in combinazione con WebAssembly.}
\end{figure}
\begin{figure}
    \begin{center}
            \includegraphics[width=1\columnwidth]{images/node_latenza.png}
    \end{center}
    \caption{Latenza misurata utilizzando Node.js}
\end{figure}
Per quanto riguarda Rust la latenza è:
\begin{align*}
    E[X]_{small}&=850ms,  & \sigma_X=154.94ms\\
    E[X]_{medium}&=1487ms, & \sigma_X=144.99ms\\
    E[X]_{large}&=4212ms,  & \sigma_X=169.95ms
\end{align*}
Per quanto riguarda Node.js, invece:
\begin{align*}
    E[X]_{small}&=704ms,  & \sigma_X=79.19ms\\
    E[X]_{medium}&=3081ms, & \sigma_X=240.58ms\\
    E[X]_{large}&=11335ms,  & \sigma_X=282.73ms
\end{align*}
Come si può facilmente notare...
\subsection{Utilizzo CPU}
blablbla
\begin{figure}
    \begin{center}
            \includegraphics[width=1\columnwidth]{images/rust_cpu.png}
    \end{center}
    \caption{Utilizzo CPU misurato utilizzando Rust in combinazione con WebAssembly.}
\end{figure}
\begin{figure}
    \begin{center}
            \includegraphics[width=1\columnwidth]{images/node_cpu.png}
    \end{center}
    \caption{Utilizzo CPU misurato utilizzando Node.js}
\end{figure}
Per quanto riguarda Rust l'utilizzo di CPU è:
\begin{align*}
    E[X]_{small}&=16.09\%,  & \sigma_X=3.32\%\\
    E[X]_{medium}&=55.35\%, & \sigma_X=3.64\%\\
    E[X]_{large}&=82.44\%,  & \sigma_X=1.93\%
\end{align*}
Per quanto riguarda Node.js, invece:
\begin{align*}
    E[X]_{small}&=20.87\%,  & \sigma_X=6.89\%\\
    E[X]_{medium}&=16.33\%, & \sigma_X=3.81\%\\
    E[X]_{large}&=18.96\%,  & \sigma_X=2.67\%
\end{align*}
Come si può notare...
\subsection{Consumo memoria}
blablbla
\begin{figure}
    \begin{center}
            \includegraphics[width=1\columnwidth]{images/rust_mem.png}
    \end{center}
    \caption{Consumo memoria misurato durante i test di Rust in combinazione con WebAssembly.}
\end{figure}
\begin{figure}
    \begin{center}
            \includegraphics[width=1\columnwidth]{images/node_mem.png}
    \end{center}
    \caption{Consumo memoria misurato utilizzando Node.js}
\end{figure}
Per quanto riguarda Rust il consumo di memoria è:
\begin{align*}
    E[X]_{small}&=50.24\text{MB},  & \sigma_X=4.91\text{MB}\\
    E[X]_{medium}&=48.79.\text{MB},  & \sigma_X=1.02\text{MB}\\
    E[X]_{large}&=47.51.\text{MB},  & \sigma_X=0.90\text{MB}\\
\end{align*}
Per quanto riguarda Node.js, invece:
\begin{align*}
    E[X]_{small}&=80.51\text{MB},  & \sigma_X=2.73\text{MB}\\
    E[X]_{medium}&=79.80\text{MB},  & \sigma_X=1.16\text{MB}\\
    E[X]_{large}&=79.92\text{MB},  & \sigma_X=1.55\text{MB}\\
\end{align*}
Come si può notare...
\newpage
\section{Qualità del codice e manutenibilità}
\section{Esperienza di sviluppo}
\section{Conclusioni}
\section{Sviluppi futuri}
\begin{lstlisting}[language=Javascript, showstringspaces=false]
\end{lstlisting}