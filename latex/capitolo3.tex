\chapter{Prototipo sviluppato}
\label{chap:3}
Nel capitolo precedente sono state esaminate le differenze sostanziali tra un'approccio basato su Rust in combinazione con WebAssmebly e uno basato su Node.js.
In questo capitolo si presenterà il prototipo sviluppato con l'obiettivo di comprendere l'impatto di tali differenze in un'applicazione pratica.
\section{Descrizione dell'applicazione}
Il prototipo sviluppato è un applicazione dedicata all'elaborazione digitale di immagini, concepita per simulare un contesto realistico in cui le operazioni richiedono una considerevole quantità di elaborazioni da parte della CPU.
\\Dato il limitato tempo disponibile, non è stato possibile esplorare a fondo il contesto del \emph{digital image processing}. Sono state invece utilizzate librerie già pronte in entrambe i linguaggi, senza scendere troppo in profondità nella programmazione di basso livello.
\\L'architettura dell'applicazione seguirà un modello client-server per entrambe le implementazioni.
In particolare il cliente sarà responsabile di fornire i file da processare e le relative specifiche sulle modifiche da apportare.
Il servitore eseguirà le modifiche richieste e risponderà al client con il percorso della nuova immagine, la quale sarà pronta per essere scaricata.
\\Nel processo di selezione delle possibili modifiche da apportare, è stato essenziale individuare due librerie nei rispettivi linguaggi utilizzati.
Successivamente, per garantire uniformità nelle opzioni di modifica disponibili, sono state estratte le seguenti funzionalità comuni: 
\begin{itemize}
    \item ridimensionamento;
    \item rotazione di 90°;
    \item ribaltamento in orizzantale;
    \item conversione in bianco e nero;
    \item aumento/diminuzione del contrasto;
    \item aumento/diminuzione di luminosità;
\end{itemize}
Tali operazioni sono state selezionate poiché rappresentano funzionalità frequentemente utilizzate anche da utenti comuni, oltre a caratterizzarsi per la loro eterogeneità. Alcune di queste coinvolgono esclusivamente la manipolazione dei pixel, come ad esempio la rotazione e il ribaltamento, mentre altre, come la conversione in scala di grigi o la modifica del contrasto/luminosità, comportano modifiche dirette sui pixel stessi.
\newpage
\section{Setup sperimentale}
\section{Metodologia}
\newpage
\section{Implementazione in Rust e Wasm/WASI}
Per quanto riguarda l'implementazione si è deciso di partire dal prototipo sviluppato in Rust in quanto era l'elemento maggiormente innovativo e dispendioso in termini di tempo impiegato.
Si è resa inoltre necessaria la ricerca di un framework che consentisse la creazione di un web server per la gestione delle richieste utente.
La scelta è ricaduta su actix-web, un web framework potente ed estremamente veloce per Rust.
Il client è costituito una semplice pagina html contenente un form per il caricamento delle immagini e due riquadri che mostrano l'immagine pre e post modifiche. Tale pagina eseguirà una richiesta AJAX al server, il quale restituirà il percorso della nuova immagine elaborata per scaricarla.
\begin{figure}
    \begin{center}
            \includegraphics[width=1\columnwidth]{images/client.png}
    \end{center}
    \caption{Pagina html del client}
    \label{fig:client}
\end{figure}
\subsection{Actix-Web}
Lo studio del funzionamento di base del framework Actix-Web ha costituito un punto focale durante la prima fase dell'implementazione.
Tale framework si è dimostrato estremamente flessibile ed adatto per lo sviluppo di un prototipo come quello di questa tesi. Grazie infatti agli \textbf{extractors}, agli\textbf{handlers} e ad altre funzionalità presenti, la gestione di richieste HTTP risulta semplice ed immediata.
Si è deciso di strutturare l'applicazione in diversi file, garantendo così una maggior pulizia e manutenibilità del codice. Il file principale è \textbf{main.rs}.
\begin{lstlisting}[language=rust, label=lst:RustWasi, caption={Porzione del file main.rs}, showstringspaces=false]
#[actix_rt::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(move || {
        App::new()
            .route("/", web::get().to(server::handlers::index))
            .route("/upload", web::post().to(server::handlers::upload))
            .service(fs::Files::new("/script", "./src/static/"))
            .service(fs::Files::new("/img", "./img/"))
            .app_data(state.clone())
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
\end{lstlisting}
Come si può notare è presente la creazione di un HttpServer e di un istanza di App. Tutti i server actix-web sono costruiti attorno all'istanza di App.
\textbf{è presente lo state!!!!! cosa fare???} Essa permette infatti, di configurare "regole di ruoting" per risorse di vario tipo, di registrare servizi HTTP e anche di contenere stato di livello applicazione. 
\\Nel nostro caso sono state configurate due regole di routing. La prima prende in considerazione richieste eseguite alle home del sito, mentre la seconda gestirà richieste per l'upload e la successiva modifica di file. Si noti che entrambe le regole di route mappano le richieste a due funzioni ("index" e "upload") presenti all'interno del file \textbf{handlers.rs} nel modulo server.
\\Successivamente sono stati registrati due servizi HTTP. Entrambi vengono utilizzati per garantire l'accesso a risorse statiche come script Javascript o immagini elaborate dall'applicazione.
\\Infine, dopo aver stabilito il metodo di dispatching delle richieste ed aver messo a disposizione le risorse necessarie ai clienti si è passati alla scrittura del codice del file "handlers.rs". Tale file, come suggerito dal nome, contiene gli handler delle richieste HTTP, con la conseguente esecuzione di codice WebAssmebly per richieste di modifica di immagini.

\begin{lstlisting}[language=rust, label=lst:RustWasi, caption={Porzione del file main.rs}, showstringspaces=false]
    #[derive(MultipartForm)]
    pub struct ImageUpload {
        image: TempFile,
        scala: Text<f32>,
        contrasto: Text<f32>,
        luminosita: Text<i32>,
        ruota: Text<bool>,
        specchia: Text<bool>,
        bw: Text<bool>
    }
    pub async fn index() -> HttpResponse {
        HttpResponse::Ok()
            .content_type("text/html")
            .body(include_str!("../static/index.html"))
    }
    pub async fn upload(form: MultipartForm<ImageUpload>) -> HttpResponse {
    ...
    }
\end{lstlisting}


\newpage
\section{Implementazione in Node.js}

\section{Valutazione delle prestazioni}
\section{Qualità del codice e manutenibilità}
\section{Esperienza di sviluppo}
\section{Scalabilità e concorrenza}
\section{Conclusioni}
\section{Sviluppi futuri}