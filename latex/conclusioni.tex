\chapter*{Conclusioni}
\addcontentsline{toc}{chapter}{Conclusioni} 
\label{Conclusioni}
Dopo aver raccolto tutti i dati necessari dai test effettuati, è stato possbile analizzarli e verificare se i vantaggi presentati dalle tecnologie emergessero anche nelle implementazioni sviluppate.
\\Come introdotto in precedenza, sono stati condotti test sul tempo di \textbf{latenza}, l'utilizzo di \textbf{CPU} e il consumo di \textbf{memoria} utilizzando una singola elaborazione tra quelle implementate (resize del 10\%), su un set di tre immagini con dimensione crescente.
\\Per quanto riguarda il tempo di latenza i due approcci hanno mostrato risultati simili solamente per richieste con l'immagine con dimensione minore. Esaminando i risultati per le altre due immagini WebAssembly ha nettamente superato Javascript, arrivando ad ottenere un tempo di latenza inferiore del 60\% per l'elaborazione dell'immagine più grande.
\\Successivamente è stato analizzato l'utilizzo della CPU. In questo caso è stato possibile notare la maggior predisposizione di WebAssembly ad un utilizzo crescente della CPU quando le circostanze lo richiedano.
Al contrario, Node.js ha mostrato un utilizzo costante anche con l'aumentare delle dimensioni delle immagini da elaborare, determinando un conseguente incremento dei tempi di latenza.
\\Per concludere i test è stato preso in esame il consumo di memoria, ma in quest'ultimo caso i due approcci non hanno mostrato differenze significative, mantenendo un utilizzo simile e costante durante tutti i test effettuati.
\\Tali risultati hanno permesso di evidenziare l'efficacia di WebAssembly su piattaforma Rust per richieste fortemente CPU-intensive.
Tuttavia hanno anche sottolineato la necessità di un'analisi approfondita per determinare quali funzionalità dell’applicazione possano effettivamente trarre beneficio da un’implementazione di questo tipo.
Inoltre, a causa della recente nascita di WebAssembly e WASI, la loro integrazione in un ambiente server side potrebbe non essere immediata, con la conseguente necessità di uno studio approfondito delle API in costante sviluppo.
\\D'altra parte Node.js offre un processo di sviluppo più lineare e coerente, grazie soprattutto all'adozione di un linguaggio consolidato come Javascript.
Tuttavia potrebbe rivelarsi una scelta non ottimale per richieste che comportano un elevato numero di elaborazioni da parte della CPU, con la possibilità di tempi di latenza elevati.
\\In conclusioe entrambi gli approcci presentano vantaggi e svantaggi a seconda delle funzionalità richieste da una determinata applicazione.
Nonostante ciò è fondamentale evidenziare il costante sviluppo di WebAssembly e WASI.
\\In futuro è previsto il rilascio di API per la gestione di richieste HTTP, l'utilizzo di socket ed altre nuove API per una gestione più avanzata del File System.
Il test di tali API di basso livello potrà risultare un'ottima estensione a questo lavoro di tesi, così da valutare l'incremento dellle prestazioni nell'ambito di un server web.
\\Inoltre, anche il numero di linguaggi che supportano l'utilizzo di moduli WASI è in crescita.
Risulterebbe particolarmente interessante condurre test utilizzando questi moduli da Node.js, combinando così la facilità di sviluppo di Javascript con l'efficienza e la portabilità offerte da WebAssembly.